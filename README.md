# 简单的手写数字识别

[TOC]

## 第一章 绪论

### 1.1 主要内容及流程

### 1.2 论文的组织结构

​	论文共分为五章，内容包含图像预处理、字符分割与字符识别等内容。

​	第一章为绪论，提出所做的主要工作和工作流程，并给出全文的组织结构。

​	第二章为图像预处理的研究，目标是图像实现图像二值化和去除噪声，对常用的三种图像二值化方法固定阈值、自适应阈值、Otsu 进行了比较；简述了形态学图像处理的腐蚀及膨胀操作，及形态学的高级形态开运算和闭运算。

​	第三章为字符分割的研究，实现的流程是，先将文本分行，再将每行的单词分开，最后分割单个字符。

## 第二章 图像预处理

### 2.1 二值化

​	摄像头拍摄的图像是彩色图像，包含的信息量巨大，对于图片的内容，可以简单的分为前景和背景，为了让计算机更快、更好地识别文字，需要对彩色图像进行处理，使图片只剩下前景信息与背景信息。可以简单的定义前景信息为白色，背景信息为黑色，这样就得到了二值化图。

​	首先使用 OpenCV 中的   `cvtColor` 函数将 RGB 图像转为灰度图像；然后，采用“图像阈值化”的方法将灰度图像的前景与背景分离。常用的阈值化方法有：(1). 固定阈值 (2). 自适应阈值 (3). Ostu

#### 2.1.1 固定阈值
​	固定阈值是一种最简单的图像二值化方法，即对于图像的所有像素，把大于某个临界灰度值的像素设为灰度最大值，而把小于这个值的像素灰度设为灰度最小值。而对于亮度不均匀的图像，无法确定一个适合于全局的阈值来将图片的前景和背景分离开，在这种情况下，应该把图片分割成小块，在每一块区域内确定一个合适的阈值，再进行分割，也就是自适应阈值。
#### 2.1.2 自适应阈值

​	自适应阈值是根据像素的邻域块的像素值分布来确定该像素位置上的二值化阈值。在灰度图像中，灰度值变化明显的区域往往是物体的轮廓，采用自适应阈值的好处在于每个像素位置处的二值化阈值不是固定不变的，而是由其周围邻域像素的分布来决定的。亮度较高的图像区域的二值化阈值通常会较高，而亮度较低的图像区域的二值化阈值则会相适应地变小。不同亮度、对比度、纹理的局部图像区域将会拥有相对应的局部二值化阈值。常用的局部自适应阈值有：(1). 局部邻域块的均值 (2). 局部邻域块的高斯加权和。

​                                    ![adaptive_threshold.png](https://ooo.0o0.ooo/2017/06/04/593392921baa5.png)

#### 2.1.3 Otsu

​	Otsu 方法是一种全局化的动态二值化方法，又叫大津法或最大类间方差算法。该算法的基本思想是，对于一幅图像，设当前景与背景的分割阈值为t时，前景点占图像比例为 $w_0$，均值为 $u_0$，背景点占图像比例为 $w_1$，均值为 $u_1$，则整个图像的均值为 $u = w_0u_0+w_1u_1$。建立目标函数 $g(t)=w_0*(u_0- u)^2+w_1(u_1-u)^2$，$g(t)$ 就是当分割阈值为t时的类间方差表达式。OTSU 算法使得g(t)取得全局最大值，当 $g(t)$ 为最大时所对应的t称为最佳阈值。大多数情况下，Otsu 算法都可以得到很好的结果。

### 1.2 噪声去除

​	现实中的数字图像在数字化和传输过程中常受到成像设备与外部环境噪声干扰等影响，称为含噪图像或噪声图像。噪声即是指妨碍计算机理解图像目标信息的内容，对于不同的文档，对噪声的定义会有所不同，根据噪声的特征进行去噪，就叫做噪声去除。图像去噪主要是在图像的频域上滤波或对图像进行形态学图像处理，常见的图像去噪方法有均值滤波器、自适应维纳滤波器、中值滤波器、形态学噪声滤除器和小波去噪。

​	本代码采用的去噪方法是形态学图像处理的闭运算，即对图像进行先膨胀后腐蚀的方法。膨胀就是图像中的高亮部分进行膨胀，即“领域扩张”，效果图拥有比原图更大的高亮区域。腐蚀就是原图中的高亮部分被腐蚀，即“领域被蚕食”，效果图拥有比原图更小的高亮区域。也就是说，膨胀和腐蚀是对图像的高亮部分而言的。

#### 1.2.1 膨胀与腐蚀

​	膨胀本质上是求局部最大值的操作，膨胀或腐蚀操作的原理是，将图像或图像的一部分区域 (A) 与核 (B) 进行卷积。核可以是任何的形状和大小，它拥有一个单独定义出来的参考点，我们称其为锚点（anchorpoint）。一般情况下，核是一个小的中间带有参考点和实心正方形或者圆盘。核 B 与图形卷积，即计算核 B 覆盖的区域的像素点的最大值，并把这个最大值赋值给参考点指定的像素。这样就会使图像中的高亮区域逐渐增长。膨胀的数学表达式为：

​                                                           $dst(x, y) = max_{(x',y')\neq0}src(x + x', y + y')$

​	效果图为：

​                                  ![dilation.png](https://ooo.0o0.ooo/2017/06/04/5933a477af906.png)

​	腐蚀和膨胀是一对相反的操作，也就是求局部最小值的操作。腐蚀的数学表达式为：

​				                         $dst(x, y) = max_{(x',y')\neq0}src(x + x', y + y')$

​	效果图为：

​                                   ![erosion.png](https://ooo.0o0.ooo/2017/06/04/5933a6b4b76b2.png)

​	膨胀与腐蚀的原理图为：![屏幕快照 2017-06-04 下午2.33.06.png](https://ooo.0o0.ooo/2017/06/04/5933a9c750106.png)



#### 1.2.2 开运算与闭运算

​	形态学的高级形态，如开运算、闭运算、形态学梯度、顶帽等是建立在腐蚀与膨胀的基础之上的。开运算（Opening Operation），其实就是先腐蚀后膨胀的过程。其数学表达式如下：

​				$dst = open(src, element)  = dilate(erode(src, element))$

​	开运算可以用来消除小物体、在纤细点处分离物体、平滑较大物体的边界的同时并不明显改变其面积。效果图为：

​                                                             ![opening.png](https://ooo.0o0.ooo/2017/06/04/5933acc018e19.png)

​	先膨胀后腐蚀的过程称为闭运算(Closing Operation)，其数学表达式如下：

​				 $dst = close(src, element) = erode(dilate(src, element))$

​	闭运算能够排除小型黑色区域。效果图如下所示：

​                                                             ![closing.png](https://ooo.0o0.ooo/2017/06/04/5933ad2b09144.png)



## 第三章 字符分割

### 3.1 分行



### 3.2 分单词



### 3.3 分字符

​	对单词中的每个字符进行分割时使用的是轮廓检测方法，OpenCV 封装了这个函数 `findContours` 。轮廓（Contours），指的是有相同颜色或者密度，连接所有连续点的一条曲线。检测轮廓的工作对形状分析和物体检测与识别都非常有用。为了提高轮廓检测的准确性，在轮廓检测之前，首先要对图片进行二值化或者 Canny 边缘检测。函数的原型为：

```python
cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]])  
```

- 第二个参数表示轮廓的检索模式，有四种：
  - `cv2.RETR_EXTERNAL` 表示只检测外轮廓
  - `cv2.RETR_LIST` 检测的轮廓不建立等级关系
  - `cv2.RETR_CCOMP` 建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。
  - `cv2.RETR_TREE` 建立一个等级树结构的轮廓。

- 第三个参数 method 为轮廓的近似办法

  - `cv2.CHAIN_APPROX_NONE` 存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即 $max(abs(x_1-x_2), abs(y_2-y_1))=1$
  - `cv2.CHAIN_APPROX_SIMPLE` 压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息
  - `cv2.CHAIN_APPROX_TC89_L1`，`CV_CHAIN_APPROX_TC89_KCOS` 使用teh-Chinl chain 近似算法

  由于检测目标是手写字母和数字，根据实际的需求，本代码中第二个参数选择的是 `cv2.RETR_EXTERNAL`  ，第三个参数选择的是  `cv2.CHAIN_APPROX_SIMPLE` 。

​                                                       <img src="https://ooo.0o0.ooo/2017/06/04/5933c6d0bef26.png" alt="contours.png" title="contours.png" style="zoom:50%"/>



## 第四章 字符识别

### 4.1 卷积神经网络

​	卷积神经网络（Convolutional Neural Network, CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现，是深度学习技术中极具代表的网络结构之一。

​	卷积神经网络由一个或多个卷积层和顶端的全连通层组成，同时也包括关联权重和池化层，这一结构使得卷积神经网络能够利用输入数据的二维结构。相比较其他深度、前馈神经网络，卷积神经网络需要估计的参数更少，在图像和语音识别方面能够给出更优的结果。

#### 4.1.1 局部连接与权值共享

​	

#### 4.1.2 结构

​	下图是一个经典的CNN结构，称为 LeNet-5网络。

![cnn.png](https://ooo.0o0.ooo/2017/06/04/5933f6073a98b.png)

​	可以看出，CNN中主要有两种类型的网络层，分别是卷积层和池化/采样层。卷积层的作用是提取图像的各种特征；池化层的作用是对原始特征信号进行抽象，从而大幅度减少训练参数，另外还可以减轻模型过拟合的程度。

1. 卷积层（Convolutional layer）

   ​	卷积层是卷积核在上一级输入层上通过逐一滑动窗口计算而得，卷积核中的每一个参数都相当于传统神经网络中的权值参数，与对应的局部像素相连接，将卷积核的各个参数与对应的局部像素值相乘之和，通常还要再加上一个偏置参数，得到卷积层上的结果。

2. 线性整流层（ReLU layer）

   ​	使用线性整流![{\displaystyle f(x)=\max(0,x)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5fa5d3598751091eed580bd9dca873f496a2d0ac)作为这一层神经的激活函数。它可以增强判定函数和整个神经网络的非线性特性，而本身并不会改变卷积层。

   ​	其他的一些函数也可以用于增强网络的非线性特性，如双曲正切函数![{\displaystyle f(x)=\tanh(x)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1a319ec32dbb0c625fa4802baf9252d1f00854e2)或者 Sigmoid 函数![{\displaystyle f(x)=(1+e^{-x})^{-1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6f6e8c1bc5646e39b558bc46f997c5db23471af5)。相比其它函数来说，ReLU 函数的优势在于它可以将神经网络的训练速度提升数倍，而并不会对模型的泛化准确度造成产生显著影响。

3. 池化层（Pooling Layer）

   ​	实际上是一种形式的向下采样。有多种不同形式的非线性池化函数，最常见的是“最大池化”：将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。其原理是，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。

   ​	CNN 的卷积层之间通常都会周期性地插入池化层。池化层通常会分别作用于每个输入的特征并减小其大小。目前最常用形式的池化层是每隔2个元素从图像划分出![2\times 2](https://wikimedia.org/api/rest_v1/media/math/render/svg/f8a0e3400ffb97d67c00267ed50cddfe824cbe80)的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。

4. 损失函数层（loss layer）

   ​	通常是网络的最后一层，用于决定训练过程如何来“惩罚”网络的预测结果和真实结果之间的差异。各种不同的损失函数适用于不同类型的任务。例如，Softmax 交叉熵损失函数常常被用于在K个类别中选出一个，而 Sigmoid 交叉熵损失函数常常用于多个独立的二分类问题。

### 4.2 TensorFlow

​	TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。

### 4.3 测试样例 



## 第五章 总结与展望

